{
  "name": "Gini",
  "tagline": "Calculate the Gini coefficient of a numpy array.",
  "body": "# gini\r\nA Gini coefficient calculator in Python.\r\n\r\n##Overview\r\nThis is a function that calculates the Gini coefficient of a numpy array. Gini coefficients are often used to quantify income inequality, read more [here](http://www.statsdirect.com/help/default.htm#nonparametric_methods/gini.htm).\r\n\r\nThe function in ```gini.py``` is based on the third equation from [here](http://www.statsdirect.com/help/default.htm#nonparametric_methods/gini.htm), which defines the Gini coefficient as:\r\n\r\n![G = \\dfrac{ \\sum_{i=1}^{n} (2i - n - 1) x_i}{n  \\sum_{i=1}^{n} x_i}](https://github.com/oliviaguest/gini/raw/master/gini.png \"Gini equation\")\r\n\r\n\r\n##Examples\r\nFor a very unequal sample, 999 zeros and a single one:\r\n```\r\n>>> from gini import *\r\n>>> a = np.zeros((1000))\r\n>>> a[0] = 1.0\r\n```\r\n\r\nThe Gini coefficient is very close to 1.0:\r\n```\r\n>>> gini(a)\r\n0.99890010998900103\r\n```\r\n\r\nFor uniformly distributed random numbers, it will be low, around 0.33:\r\n```\r\n>>> s = np.random.uniform(-1,0,1000)\r\n>>> gini(s)\r\n0.3295183767105907\r\n```\r\n\r\n##Input Assumptions\r\nThe Gini calculation by definition requires non-zero positive (ascending-order) sorted values within a 1d vector. This is dealt with within [```gini()```](https://github.com/oliviaguest/gini/blob/master/gini.py). So these four assumptions can be violated, as they are controlled for:\r\n```python\r\ndef gini(array):\r\n    \"\"\"Calculate the Gini coefficient of a numpy array.\"\"\"\r\n    # based on bottom eq: http://www.statsdirect.com/help/content/image/stat0206_wmf.gif\r\n    # from: http://www.statsdirect.com/help/default.htm#nonparametric_methods/gini.htm\r\n    array = array.flatten() #all values are treated equally, arrays must be 1d\r\n    if np.amin(array) < 0:\r\n        array -= np.amin(array) #values cannot be negative\r\n    array += 0.0000001 #values cannot be 0\r\n    array = np.sort(array) #values must be sorted\r\n    index = np.arange(1,array.shape[0]+1) #index per array element\r\n    n = array.shape[0]#number of array elements\r\n    return ((np.sum((2 * index - n  - 1) * array)) / (n * np.sum(array))) #Gini coefficient\r\n```\r\n\r\n##Notes\r\n* It is significantly faster than (the current implementation of) PySAL's Gini coefficient function (see  [pysal.inequality.gini](http://pysal.readthedocs.io/en/latest/_modules/pysal/inequality/gini.html)) and outputs are indistinguishable before approximately 6 decimal places. In other words, the two function are arithmetically identical.\r\n\r\n* It is slightly faster than the [Gini coefficient function by David on Ellipsix](http://www.ellipsix.net/blog/2012/11/the-gini-coefficient-for-distribution-inequality.html).\r\n\r\nMany other Gini coefficient functions found online do not produce equivalent results, hence why I wrote this.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}